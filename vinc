{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "ccbb15f3-d2bd-4917-9284-b69bcac99799",
   "metadata": {},
   "outputs": [],
   "source": [
    "#!/usr/bin/env python3\n",
    "# -*- coding: utf-8 -*-\n",
    "\"\"\"\n",
    "\n",
    "@author: Alejandro Murrieta (I just copied it from an old MATLAB file)\n",
    "All credit goes to RMIT in Australia\n",
    "My work was mostly to adapt it to python.\n",
    "\n",
    "Have Fun\n",
    "\"\"\"\n",
    "    \n",
    "def v_direct(coord1,coord2,maxIter=200,tol=10**-12):\n",
    "    if coord1 == coord2:\n",
    "        m=0\n",
    "        az12=0\n",
    "        return m, az12\n",
    "        \n",
    "    # Tolerance (tol) in meters\n",
    "    from math import atan\n",
    "    from math import atan2\n",
    "    from math import cos\n",
    "    from math import radians\n",
    "    from math import sin\n",
    "    from math import sqrt\n",
    "    from math import tan\n",
    "    from math import pi\n",
    "    # Test Variables\n",
    "    # maxIter=200\n",
    "    # tol=10**-12\n",
    "    # coord1 = (42.3541165, -71.0693514)\n",
    "    # coord2 = (40.7791472, -73.9680804)\n",
    "    \n",
    "    #--- CONSTANTS ------------------------------------+\n",
    "    \n",
    "    a=6378137.0                             # radius at equator in meters (WGS-84)\n",
    "    f=1/298.257223563                       # flattening of the ellipsoid (WGS-84)\n",
    "    b=(1-f)*a\n",
    "    \n",
    "    phi_1,L_1,=coord1                       # (lat=L_?,lon=phi_?)\n",
    "    phi_2,L_2,=coord2                  \n",
    "    \n",
    "    u_1=atan((1-f)*tan(radians(phi_1))) # u is psi\n",
    "    u_2=atan((1-f)*tan(radians(phi_2)))\n",
    "    \n",
    "    L=radians(L_2-L_1)\n",
    "    \n",
    "    Lambda=L                                # set initial value of lambda to L\n",
    "    \n",
    "    sin_u1=sin(u_1)\n",
    "    cos_u1=cos(u_1)\n",
    "    sin_u2=sin(u_2)\n",
    "    cos_u2=cos(u_2)\n",
    "    \n",
    "    #--- BEGIN ITERATIONS -----------------------------+\n",
    "    iters=0\n",
    "    for i in range(0,maxIter):\n",
    "        iters+=1\n",
    "        \n",
    "        cos_lambda=cos(Lambda)\n",
    "        sin_lambda=sin(Lambda)\n",
    "        sin_sigma=sqrt((cos_u2*sin(Lambda))**2+(cos_u1*sin_u2-sin_u1*cos_u2*cos_lambda)**2)\n",
    "        cos_sigma=sin_u1*sin_u2+cos_u1*cos_u2*cos_lambda\n",
    "        sigma=atan2(sin_sigma,cos_sigma)\n",
    "        sin_alpha=(cos_u1*cos_u2*sin_lambda)/sin_sigma\n",
    "        cos_sq_alpha=1-sin_alpha**2\n",
    "        cos2_sigma_m=cos_sigma-((2*sin_u1*sin_u2)/cos_sq_alpha)\n",
    "        C=(f/16)*cos_sq_alpha*(4+f*(4-3*cos_sq_alpha))\n",
    "        Lambda_prev=Lambda\n",
    "        Lambda=L+(1-C)*f*sin_alpha*(sigma+C*sin_sigma*(cos2_sigma_m+C*cos_sigma*(-1+2*cos2_sigma_m**2)))\n",
    "    \n",
    "        # successful convergence\n",
    "        diff=abs(Lambda_prev-Lambda)\n",
    "        if diff<=tol:\n",
    "            break\n",
    "        \n",
    "    u_sq=cos_sq_alpha*((a**2-b**2)/b**2)\n",
    "    A=1+(u_sq/16384)*(4096+u_sq*(-768+u_sq*(320-175*u_sq)))\n",
    "    B=(u_sq/1024)*(256+u_sq*(-128+u_sq*(74-47*u_sq)))\n",
    "    delta_sig=B*sin_sigma*(cos2_sigma_m+0.25*B*(cos_sigma*(-1+2*cos2_sigma_m**2)-(1/6)*B*cos2_sigma_m*(-3+4*sin_sigma**2)*(-3+4*cos2_sigma_m**2)))\n",
    "    \n",
    "    m=b*A*(sigma-delta_sig)                 # output distance in meters     \\\\\n",
    "    y_amm = cos_u2* sin_lambda\n",
    "    x_amm = (cos_u1 * sin_u2) - (sin_u1*cos_u2*cos_lambda)\n",
    "    alpha1_amm = atan2(y_amm,x_amm)\n",
    "    if alpha1_amm < 0:\n",
    "        alpha1_amm = alpha1_amm +2*pi\n",
    "    az12 = alpha1_amm*(180/pi);\n",
    "    return m#, az12\n",
    "    \n",
    "def v_inverse(lat1,lon1,az12,s):\n",
    "    from math import pi\n",
    "    from math import sin\n",
    "    from math import cos\n",
    "    from math import tan\n",
    "    from math import atan\n",
    "    from math import atan2\n",
    "    from math import acos\n",
    "    from math import sqrt\n",
    "    \n",
    "    # Define some constants\n",
    "    d2r = 180/pi;\n",
    "    twopi = 2*pi;\n",
    "    pion2 = pi/2;\n",
    "    # Set defining ellipsoid parameters\n",
    "    a = 6378137; # GRS80\n",
    "    flat = 298.257222101;\n",
    "\n",
    "    # Compute derived ellipsoid constants\n",
    "    f = 1/flat;\n",
    "    b = a*(1-f);\n",
    "    e2 = f*(2-f);\n",
    "    ep2 = e2/(1-e2);\n",
    "    #---------------------------------------\n",
    "    # latitude and longitude of P1 (degrees)\n",
    "    #---------------------------------------\n",
    "    # lat and lon of P1 (radians)\n",
    "    phi1 = lat1/d2r;\n",
    "    lambda1 = lon1/d2r;\n",
    "    #------------------------------------\n",
    "    # azimuth of geodesic P1-P2 (degrees)\n",
    "    #------------------------------------\n",
    "    #az12 = 1 + 43/60 + 25.876544/3600;\n",
    "    #az12=294 +38/60+ 59.528610/3600;\n",
    "    \n",
    "    # azimuth of geodesic P1-P2 (radians)\n",
    "    alpha1 = az12/d2r;\n",
    "    # sine and cosine of azimuth P1-P2\n",
    "    sin_alpha1 = sin(alpha1);\n",
    "    cos_alpha1 = cos(alpha1);\n",
    "    #------------------\n",
    "    # geodesic distance\n",
    "    #------------------\n",
    "    #s = 3692399.836991*0.75;\n",
    "    # [1] Compute parametric latitude psi1 of P1\n",
    "    psi1 = atan((1-f)*tan(phi1));\n",
    "    # [2] Compute parametric latitude of vertex\n",
    "    psi0 = acos(cos(psi1)*sin_alpha1);\n",
    "\n",
    "# [3] Compute geodesic constant u2 (u-squared)\n",
    "    u2 = ep2*(sin(psi0)**2);\n",
    "# [4] Compute angular distance sigma1 on the auxiliary sphere from equator\n",
    "# to P1'\n",
    "    sigma1 = atan2(tan(psi1),cos_alpha1);\n",
    "# [5] Compute the sine of the azimuth of the geodesic at the equator\n",
    "    sin_alphaE = cos(psi0);\n",
    "# [6] Compute Vincenty's constants A and B\n",
    "    A = 1 + u2/16384*(4096 + u2*(-768 + u2*(320-175*u2)));\n",
    "    B = u2/1024*(256 + u2*(-128 + u2*(74-47*u2)));\n",
    "    # [7] Compute sigma by iteration\n",
    "    sigma = s/(b*A);\n",
    "    iterat = 1;\n",
    "    while 1:\n",
    "        two_sigma_m = 2*sigma1 + sigma;\n",
    "        s1 = sin(sigma);\n",
    "        s2 = s1*s1;\n",
    "        c1 = cos(sigma);\n",
    "        c1_2m = cos(two_sigma_m);\n",
    "        c2_2m = c1_2m*c1_2m;\n",
    "        t1 = 2*c2_2m-1;\n",
    "        t2 = -3+4*s2;\n",
    "        t3 = -3+4*c2_2m;\n",
    "        delta_sigma = B*s1*(c1_2m+B/4*(c1*t1-B/6*c1_2m*t2*t3));\n",
    "        sigma_new = s/(b*A)+delta_sigma;\n",
    "        if abs(sigma_new-sigma) < 1e-12 :\n",
    "            break\n",
    "        sigma = sigma_new;\n",
    "        iterat = iterat + 1;\n",
    "\n",
    "    s1 = sin(sigma);\n",
    "    c1 = cos(sigma);\n",
    " # [8] Compute latitude of P2\n",
    "    y = sin(psi1)*c1+cos(psi1)*s1*cos_alpha1;\n",
    "    x = (1-f)*sqrt(sin_alphaE**2+(sin(psi1)*s1-cos(psi1)*c1*cos_alpha1)**2);\n",
    "    phi2 = atan2(y,x);\n",
    "    lat2 = phi2*d2r;\n",
    "# [9] Compute longitude difference domega on the auxiliary sphere\n",
    "    y = s1*sin_alpha1;\n",
    "    x = cos(psi1)*c1-sin(psi1)*s1*cos_alpha1;\n",
    "    domega = atan2(y,x);\n",
    "# [10] Compute Vincenty's constant C\n",
    "    x = 1-sin_alphaE**2;\n",
    "    C = f/16*x*(4+f*(4-3*x));\n",
    "    # [11] Compute longitude difference on ellipsoid\n",
    "    two_sigma_m = 2*sigma1 + sigma;\n",
    "    c1_2m = cos(two_sigma_m);\n",
    "    c2_2m = c1_2m*c1_2m;\n",
    "    dlambda = domega-(1-C)*f*sin_alphaE*(sigma+C*s1*(c1_2m+C*c1*(-1+2*c2_2m)));\n",
    "    dlon = dlambda*d2r;\n",
    "    lon2 = lon1+dlon;\n",
    "    # [12] Compute azimuth alpha2\n",
    "    y = sin_alphaE;\n",
    "    x = cos(psi1)*c1*cos_alpha1-sin(psi1)*s1;\n",
    "    alpha2 = atan2(y,x);\n",
    "    # [13] Compute reverse azimuth az21\n",
    "    az21 = alpha2*d2r + 180;  \n",
    "    if az21 > 360 :\n",
    "        az21 = az21-360;\n",
    "        \n",
    "    return lat2,lon2\n",
    "    \n",
    "## TEST CODE BEGINS HERE\n",
    " \n",
    "#\n",
    "#    \n",
    "#boston = (42.3541165, -71.0693514)\n",
    "#newyork = (40.7791472, -73.9680804)\n",
    "# \n",
    "#distance,azimuth = direct(boston, newyork)  # Meteres, degrees\n",
    "#print(distance)  # 298396.05747326626 mts\n",
    "#print(azimuth)   # 235.0838926191198  degrees\n",
    "#\n",
    "## Define a waypoint\n",
    "## vinc_in(lat, lon, alpha12, s ) \n",
    "#\n",
    "#lat2,lon2 = inverse(boston[0],boston[1],azimuth,distance)\n",
    "#print(lat2)     # 40.77914719998252\n",
    "#print(lon2)     # -73.96808039994268\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "79b7ab51-19c9-4bb8-a0bb-5f1de6eacfd8",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
